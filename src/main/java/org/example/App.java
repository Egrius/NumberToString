package org.example;

/*
Планы:
    - отдельные методы для обработки каждого разряда (единицы, десятки, сотни и т.д). getRepresentation() выглядит стрёмно
    - обработка отрицательных чисел
    - поддерживать большие числа
    P.s. Возможно стоит разбивать число на группы по 3:
    1084 можно представить как [10] и [84] или [108] и [4],
    НООО, тогда проблема: если у меня 1004, хотя, если написать функции под каждый разряд, то можно пробегаться
    по массиву до момента пока не нуль и тем самым писать правильное название.
    Еще одна мысль: разбивать числа по типу 98000201 как [98], [0002], [01],
    тогда опираясь от count можно делать разряды проще

    P.S. После написания отдельных методов реализовать функцию, вызывающую эти функции в соответсвии с разрядностью.
    Реализовать логику по принципу разбиения на разряды миллионов, тысяч, сотен, опираясь от count и игнорировать нули.
 */

public class App 
{
    public static void main( String[] args )
    {
        NumberTranslator numberTranslator = new NumberTranslator(14);
        String result = numberTranslator.printNumber();
        System.out.println(result);
    }
}
